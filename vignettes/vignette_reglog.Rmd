---
title: "Reglog : package pour la réalisation de régressions logistiques"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Reglog}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE,comment = "#>")
library(kableExtra)
library(tidyverse)
library(readr)
   DF <- read_delim("../data/thesepsyclean.csv",";", escape_double = FALSE, trim_ws = TRUE)
   DF -> DF_sep
   y <- "Recidive"
#####
DF$antecedent_familiaux[DF$antecedent_familiaux != "non" & !is.na(DF$antecedent_familiaux)] <- "oui"
DF$scolarite[DF$scolarite == "ITEP"] <- "difficultés scolaires"
DF$scolarite[DF$scolarite == "difficulés scolaires"] <- "difficultés scolaires"
DF$scolarite[DF$scolarite == "descolarite"] <- "descolaritee"
DF$facteur_precipitant[DF$facteur_precipitant == "décès d'un proche"] <- "problèmes familiaux"
DF$facteur_precipitant[DF$facteur_precipitant == "conflit familial"] <- "problemes familiaux"
DF$diagnostic[DF$diagnostic == "TDAH" ] <- "TDA/C"
DF$diagnostic[DF$diagnostic == "trouble du spectre autistique"] <- "TDA/C"
DF$diagnostic[DF$diagnostic == "trouble des conduites"] <- "TDA/C"
DF$diagnostic[DF$diagnostic == "trouble bipolaire"] <- "trouble de l'humeur"
DF$diagnostic[DF$diagnostic == "épisode dépressif"] <- "trouble de l'humeur"
DF$mode[DF$mode == "Ingestion de produit toxique" ] <- "IMV"
DF$suivi[DF$suivi == "CMP"] <- "autre"
DF$TTT[DF$TTT == "thymorégulateur"] <- "autre"
DF$conduite_risque[DF$conduite_risque == "fugue"] <- "autre"
DF$conduite_risque[DF$conduite_risque == "risque sexuel"] <- "autre"
DF$lieu_vie[DF$lieu_vie == "placement"] <- "autre"
#####
```

Le package autostats fournit la fonction reglog, reglin et table1.<br><br>
La fonction *reglog* permet la réalisation automatique d'une regression logistique avec:<br>
\ \ \ * préparation des données avec gestion des données manquantes<br>
\ \ \ * régression logistique univariée pour toutes les variables<br>
\ \ \ * sélection d'un modèle de regression logistique multivarié avec sélection automatique ou manuelle des variables<br>
\ \ \ * mise en forme des résultats en matrice, dataframe, tableau excel ou tableau html (*package kable*)<br>
<br>
Pour réaliser la regression logistique complète, soit la fonction *reglog* est lancée, soit chaque fonction est appelée indépendamment. Le détail de chaque fonction indépendante est détaillé dans cette vignette ; les lancer toute à la suite avec les paramètres par défault ou lancer la fonction *reglog* est strictement équivalent. <br>
<br>
**Remarque** : les datasets d'illustration sont libres et fournit avec le package. Plus d'informations avec la fonction help().

<br><br><br>

# Installation

Le code source est entièrement disponible à l'adresse suivante : https://github.com/TanguyPerennec/autostats.git. <br/><br/>
Le package peut être installé depuis la console R avec la commande : *install_github("TanguyPerennec/autostats")* (nécessite le package *devtools*).

```{r setup}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```


```{r installation, message=FALSE, warning=FALSE}
library(autostats)
```

<br><br>

# Nettoyage des données : *"data_prep_complete( )"*

La fonction *"data_prep_complete( )"* réalise un nettoyage complet des données et constitue une préparation pour la regression logistique. Elle permet dans la majorité des situations de passer d'un jeu de donnée non compatible avec la fonction *glm()* à un jeu de donnée compatible et optimisé (suppression des doublons, suppression ou imputation des données manquantes, etc.).<br>
<br>
Elle contient les fonctions suivantes, qui peuvent être appelées séparemment et indépendemment :

## 1. Formatage : *format_data( )*

La fonction format_data() transforme les variables character en minuscules sans accent. Le formatage par défaut des données évite les erreurs de facteurs en supprimant les accents et les majuscules. La fonction est optimisée pour la langue française mais ne s'y limite pas (suppression de la majorité des accents latins). La fonction est rapide : son temps d'exécution est de 1 seconde pour 150 000 observations. L'intérêt d'éviter son exécution pour un jeu de donnée d'emblée formaté (en UFT-8) de taille raisonable est donc limité.

```{r format_data,echo=TRUE}
levels(as.factor(DF$facteur_precipitant))
DF <- format_data(DF, type = c("plain"))
levels(as.factor(DF$facteur_precipitant))
```

L'option *'type = "no-plural"'* permet en plus de regrouper des modalités de facteurs ne différant que d'une mise au pluriel. La fonction opère une comparaison entre tous les facteurs d'une colonne et fusionne deux modalités ne differant que d'un ou plusieurs "s" en dernière lettre des mots. Ainsi, "porteurs sain" et "porteur sain" seront fusionnées mais "case" et "casse" ne le seront pas.<br>
*Remarque : pour le moment les pluriels irréguliés ne sont pas pris en charge*

```{r format_data_plural}
levels(as.factor(DF$scolarite))
DF <- format_data(DF, type = c("plain","no-plural"))
levels(as.factor(DF$scolarite))

```

Les options *type = c("no-fem","no-femplur")* complète la fonction précédente avec des facteurs dont les modalitées ne diffèrent que par les dernières lettres des mots, par "e" et "es" respectivement.

### fonction supplémentaires

- Supression des espaces en première et dernière position <br>
- Suppression des espaces doubles


## 2. Transformation d'une variable en facteur binaire 1 / 0 : *as.binary()*

Cette fonction transforme une variable binaire catégorielle en facteur binaire 1 ou 0.<br>
Si un niveau du facteur initial contient les mots *"non", "no" ou "not"* il est automatiquement considéré comme le niveau 0. Sinon, c'est le premier niveau par défaut (ou spécifié par la fonction *relevel*) qui est considéré comme la référence, et devient donc le 0.
<br><br>
Lors de l'appel de la fonction reglog, "y" est toujours transformé par cette fonction. Les autres variables ne le sont pas.

```{r echo=TRUE}
DF <- as.data.frame(DF)
DF[,y] <- tobinary(DF[,y])
```



## 3. Suppression des données manquantes : *NA_rm_for_glm()*

Cette fonction supprime les lignes contenant un ou plusieurs NA, afin d'obtenir une population sans données manquante, préalable indispensable à la régression logistique.<br>

```{r echo=TRUE}
DF <- NA_rm_for_glm(DF,y,method_NA = c("lessNA", "significance"),verbose = F)
```

**Attention** : cette fonction supprime des colonnes si le nombre de lignes restantes est inférieure à un certain seuil (*cf EPV*), selon une méthode pouvant être spécifiée dans l'argument *method_NA* :<br>
\ \ \ * *lessNA* : supprime les colonnes par ordre de nombre de NA décroissant (recalculé à chaque itération)<br>
\ \ \ * *significance* : supprime les variables dont la regression univariée ne diffère pas de manière significative avec le modèle nul (rapport de vraissemblance) au risque 0.5 (modifiable avec *flor_pval*), sur leur population.<br>
<br><br>

Pour conserver certaines colonnes, il faut renseigner d'autres arguments :<br>
\ \ \ * conserver quelques colonnes spécifiques : renseigner l'argument *keep = c(variables à conserver)* <br>
\ \ \ * conserver toutes les colonnes : *method_NA = NULL*.<br>
\ \ \ * conserver un certain nombre de colonnes : *min_multivariate* = nb minimal de colonnes à conserver (par défault 10%)<br>
\ \ \ * choisir une méthode d'imputation des données manquantes (cf point suivant)<br><br>

Attention, ces méthodes ne garantissent plus un taux d'évènement par variable (*EPV*) suffisant et risque de biaiser le modèle final<br>

### Méthodes d'imputation des données manquantes
Plusieurs méthodes sont possibles. Renseigner les colonnes consernées dans l'argument correspondant :<br>
\t   \  - *NA* : considère les NA comme des modalitées indépendantes<br>
\t   \  - *median*, *mean* : remplace les NA par la médiane/moyenne de la variable <br>
\t   \  - *kNN* : méthode de k plus proches voisins : impute le NA par la valeur correspondante de l'observation la plus semblable par ailleurs <br>
\t   \  - *rf* : méthode des forêts aléatoires<br><br>

*Attention* : certaine de ces fonctions peuvent prendre du temps, jusqu'à 0.4 secondes pour cet exemple à plusieurs minutes pour le jeu de données INCA3 de plusieurs miliers d'observations.


```{r imputation datas}
# Creation of a new dataset with random NAs
set.seed(645)
sample(x = c(0,1),size = 40, replace = TRUE) -> AVC
sample(x = c(0,1),size = 40, replace = TRUE) -> sexe
rnorm(n = 40,mean = 50,sd = 15) + sexe*20  -> poids
rnorm(n = 40,mean = 160,sd = 15) + sexe*13  -> taille
sample(x = c(0,1),size = 40, replace = TRUE) -> fumeur
round(sexe * 0.05 + poids * 0.009 + fumeur * 0.04 - rnorm(n = 1, mean = 0.2, sd = 0.08),0) -> HTA
DF1 <- cbind(AVC,sexe,poids,taille,fumeur,HTA)
DF_NA <- DF1 
sample(17,5) -> nb_NA
for (n in seq(nb_NA))
{
  sample(40,nb_NA[n]) -> NA_introduced
  DF_NA[NA_introduced,n + 1] <- NA
}
```


```{r imputation}
DF_kNN <- NA_rm_for_glm(DF_NA,y = "AVC",kNN = colnames(DF_NA),method_NA = NULL)
#DF_rf <- NA_rm_for_glm(DF_NA,y = "AVC",rf = colnames(DF_NA),method_NA = NULL)
DF_median <- NA_rm_for_glm(DF_NA,y = "AVC",median = colnames(DF_NA),method_NA = NULL)
DF_NAvar <- NA_rm_for_glm(DF_NA,y = "AVC",NA_as_level = colnames(DF_NA),method_NA = NULL)
DF_NA %>%   kable(format = "html", escape = F, digits = 1) %>%
  kable_styling(bootstrap_options = c("striped", "hover","condensed","responsive",full_width = F), position = "float_left") %>%
  scroll_box(width = "300px", height = "350px")
DF_kNN %>%   kable(format = "html", escape = F, digits = 1) %>%
  kable_styling(bootstrap_options = c("striped", "hover","condensed","responsive",full_width = F), position = "float_left") %>%
  scroll_box(width = "300px", height = "350px")
#DF_rf
DF_median %>%   kable(format = "html", escape = F, digits = 1) %>%
  kable_styling(bootstrap_options = c("striped", "hover","condensed","responsive",full_width = F), position = "float_left") %>%
  scroll_box(width = "300px", height = "350px")
DF_NAvar %>%   kable(format = "html", escape = F, digits = 1) %>%
  kable_styling(bootstrap_options = c("striped", "hover","condensed","responsive",full_width = F), position = "center") %>%
  scroll_box(width = "300px", height = "350px")
```


<br>
<br>

### EPV

Le nombre minimum d'évènements par variable est initialement (et traditionnellement) fixé à 10.<br><br>
D'autres méthodes pour estimer la taille de l'échantillon seront implémentées dans les versions suivantes car l'EPV n'est pas toujours une méthode fiable (<a href="https://journals.sagepub.com/doi/pdf/10.1177/0962280218784726">van Smeden et al.</a>). 

<br>
<br><br>
<br>

# Regression logistique

## *formulation()*

La fonction *formulation()* permet de créer un objet de class 'formule' à partir d'un vecteur ou d'un dataframe.

```{r formulation}
#Pour une formule sur l'ensemble du dataframe :
formulation(DF)
#Pour un vecteur
vector <-  c("Recidive","Age","Sexe")
formulation(vector)
```


## Regression logistique : *logit()*

La fonction *logit()* réalise une régression logistique.<br>
Elle se différencie de la fonction *stats::glm(DF,y,family="binomial")* par le fait qu'une séparation complète ou quasi-complète est détectée par un test d'existence du maximum de vraissemblance et non plus par la non convergence à un nombre d'itération donné. Cette fonction s'appuie sur le package **safeBinaryRegression** de Kjell Konis. La séparation complète ou quasi-complète est traitée par la fonction *complete_separation()* (cf point suivant).<br><br>

**Attention** : l'obtention d'une estimation du maximum de vraissenblance étant un prérequis indispensable à la comparaison de modèles entre-eux, la sélection de variables pour le modèle multivarié n'est pas réalisable en cas d'utilisation des méthodes "do-nothing" ou "Firth".

```{r logit}
#logit(DF)
```


### Séparation complète : *complete_separation()*


```{r complete_separation}

```

# Selection des variables pour le modèle multivarié : *multivariate_selection()*

## Principes généraux 

Pour la sélection des variables pour un modèle multivarié, le principe est de selectionner le meilleur modèle m, tel que tous les autres modèles selectionnant d'autres variables contre lequel il est comparé soient jugés moins bon. Il faut donc renseigner le critère de sélection (critère de choix entre modèle), et la méthode de sélection (comment sélectionner les modèles à comparer : tous ensemble ou "un à un" et dans ce cas dans quel ordre).<br><br>

Le critère de sélection du meilleur modèle est à renseigner dans l'argument **criteria** : <br/> 
\t - la *déviance* : disponible qu'entre modèles emboités (méthode "bestsubset" indisponible)<br/> 
\t - l'*AIC* : pénalise le nombre de modalités<br/> 
\t - le *BIC* : pénalise le nombre de modalités en fonction du nombre d'observation<br/><br/>  

Le "sens" est donné par l'argument **"method"** :<br>
\t - *forward* : inclusion à chaque step de la variable permettant le meilleur modèle, à partir du modèle nul jusqu'au modèle ne permettant plus d'amélioration au risque *alpha* ou *delta* selon le critère<br>
\t - *backard* : suppression à chaque step de la variable permettant d'améliorer le plus le modèle, du modèle complet jusqu'au modèle ne permettant plus d'amélioration au risque *alpha* ou *delta* selon le critère<br>
\t - *forward stepwise* : à chaque step forward, une étape step backward est ajoutée<br>
\t - *backward stepwise* : à chaque step backward, une étape step forward est ajoutée<br>
\t - *backward augmented* : à chaque étape, estimation du changement relatif du coefficient de chaque autre critère restés dans le modèle. La variable est ainsi de nouveau inclue si un coefficient est supérieur à 20%.<br>
\t - *forward stepwise augmented*<br>
\t - *backward stepwise augmented*<br>
\t - *bestsubset*<br>
\t - *univariate selection* : selection de toute les variables dont le test de Wald est significatif au risque alpha en univarié<br>
\t - *LASSO*<br>
<br><br>
Au total, il y a donc 7\*3+2+1+1 = **25 méthodes de sélection possibles**.

```{r mvs}
s_dev_back <- multivariate_selection(DF,y = "Recidive",criteria = "deviance",method = "backward")
s_dev_back
```

```{r}
s_AIC_back <- multivariate_selection(DF,y = "Recidive",criteria = "AIC",method = "backward")
s_AIC_back
```

```{r}
s_BIC_back <- multivariate_selection(DF,y = "Recidive",criteria = "BIC",method = "backward")
s_BIC_back
```

```{r}
s_dev_for <- multivariate_selection(DF,y = "Recidive",criteria = "deviance",method = "forward")
s_dev_for
```

```{r}
s_AIC_for <- multivariate_selection(DF,y = "Recidive",criteria = "AIC",method = "forward")
s_AIC_for
```

```{r}
s_BIC_for <- multivariate_selection(DF,y = "Recidive",criteria = "BIC",method = "forward")
s_BIC_for
```

```{r}
s_BIC_for <- multivariate_selection(DF,y = "Recidive",criteria = "BIC",method = "forward")
s_BIC_for
```

```{r}
s_dev_forstep <- multivariate_selection(DF,y = "Recidive",criteria = "deviance",method = "forward stepwise")
s_AIC_forstep <- multivariate_selection(DF,y = "Recidive",criteria = "AIC",method = "forward stepwise")
s_BIC_forstep <- multivariate_selection(DF,y = "Recidive",criteria = "BIC",method = "forward stepwise")
```

```{r}
s_dev_backstep <- multivariate_selection(DF,y = "Recidive",criteria = "deviance",method = "backward stepwise")
s_AIC_backstep <- multivariate_selection(DF,y = "Recidive",criteria = "AIC",method = "backward stepwise")
s_BIC_backstep <- multivariate_selection(DF,y = "Recidive",criteria = "BIC",method = "backward stepwise")

```

## Methodes supplémentaires

### Variables à conserver

Si des variables doivent être conservées dans le modèle final (dans le cas d'interaction connue avec y par exemple), renseigner l'option keep avec le nom de ces variables.<br>

### Principal factor

Le facteur principal est un facteur que l'on veut spécifiquement tester vis à vis de la variable à expliquer. Dans ce cas, elle n'est jamais supprimée, est inclue en premier dans la méthode forward et est la variable inclue pour la recherche de variable d'interaction ; tout cela quel que soit sont coefficient ou valeur de test associée.<br>

### Variables d'interactions
La fonction check_interaction permet de vérifier en premier lieu la présence d'interaction en le facteur principal et les autres variables. Si tel est le cas, les variables d'interactions sont ajoutées au modèle.<br>


# Recap

```{r echo=FALSE}
matrice_rslt <- matrix(nrow = (ncol(DF) - 1),ncol = 13)
rownames(matrice_rslt) <- colnames(DF)[colnames(DF) != y]
colnames(matrice_rslt) <- c("dev_back","dev_for","dev_forstep","dev_backstep","AIC_back","AIC_for","AIC_forstep","AIC_backstep","BIC_back","BIC_for","BIC_forstep","BIC_backstep","total")
m = 1
for (var in rownames(matrice_rslt))
{
  matrice_rslt[m,1] <- ifelse(var %in% s_dev_back$vars_multi,"O","-")
  matrice_rslt[m,2] <- ifelse(var %in% s_dev_for$vars_multi,"O","-")
  matrice_rslt[m,3] <- ifelse(var %in% s_dev_forstep$vars_multi,"O","-")
  matrice_rslt[m,4] <- ifelse(var %in% s_dev_backstep$vars_multi,"O","-")
  matrice_rslt[m,5] <- ifelse(var %in% s_AIC_back$vars_multi,"O","-")
  matrice_rslt[m,6] <- ifelse(var %in% s_AIC_for$vars_multi,"O","-")
  matrice_rslt[m,7] <- ifelse(var %in% s_AIC_forstep$vars_multi,"O","-")
  matrice_rslt[m,8] <- ifelse(var %in% s_AIC_backstep$vars_multi,"O","-")
  matrice_rslt[m,9] <- ifelse(var %in% s_BIC_back$vars_multi,"O","-")
  matrice_rslt[m,10] <- ifelse(var %in% s_BIC_for$vars_multi,"O","-")
  matrice_rslt[m,11] <- ifelse(var %in% s_BIC_forstep$vars_multi,"O","-")
  matrice_rslt[m,12] <- ifelse(var %in% s_BIC_backstep$vars_multi,"O","-")
  m + 1 -> m
}
as.data.frame(matrice_rslt) -> matrice
matrice$total <- rep(0,nrow(matrice))

for (j in seq(nrow(matrice)))
{
  sum(matrice[j,1:9] == "O")/(nrow(matrice)-1) -> matrice$total[j]
}
matrice[order(-matrice$total),] -> matrice


matrice %>%
 mutate(
    Colonnes = row.names(.),
    dev_back = cell_spec(dev_back, "html", color = ifelse(dev_back == "O", "red", "blue")),
    dev_for = cell_spec(dev_for, "html", color = ifelse(dev_for == "O", "red", "blue")),
    dev_forstep = cell_spec(dev_forstep, "html", color = ifelse(dev_forstep == "O", "red", "blue")),
    dev_backstep = cell_spec(dev_backstep, "html", color = ifelse(dev_backstep == "O", "red", "blue")),
    AIC_back = cell_spec(AIC_back, "html", color = ifelse(AIC_back == "O", "red", "blue")),
    AIC_for = cell_spec(AIC_for, "html", color = ifelse(AIC_for == "O", "red", "blue")),
    AIC_forstep = cell_spec(AIC_forstep, "html", color = ifelse(AIC_forstep == "O", "red", "blue")),
    AIC_backstep = cell_spec(AIC_backstep, "html", color = ifelse(AIC_backstep == "O", "red", "blue")),
    BIC_back = cell_spec(BIC_back, "html", color = ifelse(BIC_back == "O", "red", "blue")),
    BIC_for = cell_spec(BIC_for, "html", color = ifelse(BIC_for == "O", "red", "blue")),
    BIC_forstep = cell_spec(BIC_forstep, "html", color = ifelse(BIC_forstep == "O", "red", "blue")),
    BIC_backstep = cell_spec(BIC_backstep, "html", color = ifelse(BIC_backstep == "O", "red", "blue")),
    total) %>%
  kable(format = "html", escape = F, digits = 1) %>%
  kable_styling(bootstrap_options = c("striped", "hover","condensed","responsive",full_width = F), position = "center")
```
## Stabilité
```{r}

rslt <- matrix(ncol = 2,nrow = length(colnames(DF)[colnames(DF) != y]))
rslt[,1] <- colnames(DF)[colnames(DF) != y]
rslt[,2] <- rep(0,nrow(rslt))
nbre = 100
for (i in 1:nbre)
{
  sample(nrow(DF), nrow(DF), replace = TRUE) -> colDF
  newDF <- DF[colDF, ]
  newDF$toxiques <- NULL
  s_dev_back <- multivariate_selection(newDF,
                           y = "Recidive",
                           criteria = "BIC",
                           method = "backward")
  for (var in colnames(DF)[colnames(DF) != y])
  {
    if (var %in% s_dev_back$vars_multi)
    {
      rslt[match(var,rslt[,1]),2] <- as.numeric(rslt[match(var,rslt[,1]),2]) + 1
    }
  }
}
round((as.numeric(rslt[,2])/nbre)*100,1) -> rslt[,2]
as.data.frame(rslt[order(as.numeric(rslt[,2])),]) -> rslt
colnames(rslt) <- c("variables","% inclusion")
rslt %>% kable()

#clopper pearson
```

